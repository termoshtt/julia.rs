/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const jl_setjmp_name: &'static [u8; 12usize] = b"__sigsetjmp\0";
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub type sig_atomic_t = __sig_atomic_t;
pub type uv__io_cb = ::std::option::Option<
    unsafe extern "C" fn(loop_: *mut uv_loop_s, w: *mut uv__io_s, events: ::std::os::raw::c_uint),
>;
pub type uv__io_t = uv__io_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv__io_s {
    pub cb: uv__io_cb,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pevents: ::std::os::raw::c_uint,
    pub events: ::std::os::raw::c_uint,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv__io_s() {
    assert_eq!(
        ::std::mem::size_of::<uv__io_s>(),
        56usize,
        concat!("Size of: ", stringify!(uv__io_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv__io_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv__io_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pending_queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).watcher_queue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).pevents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(pevents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).events as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv__io_s>())).fd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv__io_s),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_buf_t {
    pub base: *mut ::std::os::raw::c_char,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_uv_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<uv_buf_t>(),
        16usize,
        concat!("Size of: ", stringify!(uv_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_buf_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_buf_t>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_buf_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_buf_t>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_buf_t),
            "::",
            stringify!(len)
        )
    );
}
pub type uv_os_fd_t = ::std::os::raw::c_int;
pub type uv_mutex_t = pthread_mutex_t;
pub type uv_rwlock_t = pthread_rwlock_t;
pub const uv_handle_type_UV_UNKNOWN_HANDLE: uv_handle_type = 0;
pub const uv_handle_type_UV_ASYNC: uv_handle_type = 1;
pub const uv_handle_type_UV_CHECK: uv_handle_type = 2;
pub const uv_handle_type_UV_FS_EVENT: uv_handle_type = 3;
pub const uv_handle_type_UV_FS_POLL: uv_handle_type = 4;
pub const uv_handle_type_UV_HANDLE: uv_handle_type = 5;
pub const uv_handle_type_UV_IDLE: uv_handle_type = 6;
pub const uv_handle_type_UV_NAMED_PIPE: uv_handle_type = 7;
pub const uv_handle_type_UV_POLL: uv_handle_type = 8;
pub const uv_handle_type_UV_PREPARE: uv_handle_type = 9;
pub const uv_handle_type_UV_PROCESS: uv_handle_type = 10;
pub const uv_handle_type_UV_STREAM: uv_handle_type = 11;
pub const uv_handle_type_UV_TCP: uv_handle_type = 12;
pub const uv_handle_type_UV_TIMER: uv_handle_type = 13;
pub const uv_handle_type_UV_TTY: uv_handle_type = 14;
pub const uv_handle_type_UV_UDP: uv_handle_type = 15;
pub const uv_handle_type_UV_SIGNAL: uv_handle_type = 16;
pub const uv_handle_type_UV_FILE: uv_handle_type = 17;
pub const uv_handle_type_UV_HANDLE_TYPE_MAX: uv_handle_type = 18;
pub type uv_handle_type = u32;
pub const uv_req_type_UV_UNKNOWN_REQ: uv_req_type = 0;
pub const uv_req_type_UV_REQ: uv_req_type = 1;
pub const uv_req_type_UV_CONNECT: uv_req_type = 2;
pub const uv_req_type_UV_WRITE: uv_req_type = 3;
pub const uv_req_type_UV_SHUTDOWN: uv_req_type = 4;
pub const uv_req_type_UV_UDP_SEND: uv_req_type = 5;
pub const uv_req_type_UV_FS: uv_req_type = 6;
pub const uv_req_type_UV_WORK: uv_req_type = 7;
pub const uv_req_type_UV_GETADDRINFO: uv_req_type = 8;
pub const uv_req_type_UV_GETNAMEINFO: uv_req_type = 9;
pub const uv_req_type_UV_REQ_TYPE_MAX: uv_req_type = 10;
pub type uv_req_type = u32;
pub type uv_loop_t = uv_loop_s;
pub type uv_handle_t = uv_handle_s;
pub type uv_stream_t = uv_stream_s;
pub type uv_tcp_t = uv_tcp_s;
pub type uv_async_t = uv_async_s;
pub type uv_signal_t = uv_signal_s;
pub type uv_shutdown_t = uv_shutdown_s;
pub type uv_connect_t = uv_connect_s;
pub type uv_alloc_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_handle_t, suggested_size: usize, buf: *mut uv_buf_t),
>;
pub type uv_read_cb = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut uv_stream_t, nread: isize, buf: *const uv_buf_t),
>;
pub type uv_connect_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_connect_t, status: ::std::os::raw::c_int),
>;
pub type uv_shutdown_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut uv_shutdown_t, status: ::std::os::raw::c_int),
>;
pub type uv_connection_cb = ::std::option::Option<
    unsafe extern "C" fn(server: *mut uv_stream_t, status: ::std::os::raw::c_int),
>;
pub type uv_close_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_handle_t)>;
pub type uv_async_cb = ::std::option::Option<unsafe extern "C" fn(handle: *mut uv_async_t)>;
pub type uv_signal_cb = ::std::option::Option<
    unsafe extern "C" fn(handle: *mut uv_signal_t, signum: ::std::os::raw::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_shutdown_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub handle: *mut uv_stream_t,
    pub cb: uv_shutdown_cb,
}
#[test]
fn bindgen_test_layout_uv_shutdown_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_shutdown_s>(),
        80usize,
        concat!("Size of: ", stringify!(uv_shutdown_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_shutdown_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_shutdown_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).handle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_shutdown_s>())).cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_shutdown_s),
            "::",
            stringify!(cb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_handle_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uv_handle_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_handle_s>(),
        64usize,
        concat!("Size of: ", stringify!(uv_handle_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_handle_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_handle_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_handle_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_handle_s),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_stream_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uv_stream_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_stream_s>(),
        216usize,
        concat!("Size of: ", stringify!(uv_stream_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_stream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_stream_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).write_queue_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).alloc_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).read_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).connect_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).shutdown_req as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).io_watcher as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).write_queue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_stream_s>())).write_completed_queue as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).connection_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).delayed_error as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).accepted_fd as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_stream_s>())).queued_fds as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_stream_s),
            "::",
            stringify!(queued_fds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_tcp_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub write_queue_size: usize,
    pub alloc_cb: uv_alloc_cb,
    pub read_cb: uv_read_cb,
    pub connect_req: *mut uv_connect_t,
    pub shutdown_req: *mut uv_shutdown_t,
    pub io_watcher: uv__io_t,
    pub write_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub write_completed_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub connection_cb: uv_connection_cb,
    pub delayed_error: ::std::os::raw::c_int,
    pub accepted_fd: ::std::os::raw::c_int,
    pub queued_fds: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_uv_tcp_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_tcp_s>(),
        216usize,
        concat!("Size of: ", stringify!(uv_tcp_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_tcp_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_tcp_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_queue_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_queue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).alloc_cb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(alloc_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).read_cb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(read_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).connect_req as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(connect_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).shutdown_req as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(shutdown_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).io_watcher as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_queue as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).write_completed_queue as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(write_completed_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).connection_cb as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(connection_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).delayed_error as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(delayed_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).accepted_fd as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(accepted_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_tcp_s>())).queued_fds as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_tcp_s),
            "::",
            stringify!(queued_fds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_connect_s {
    pub data: *mut ::std::os::raw::c_void,
    pub type_: uv_req_type,
    pub active_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub cb: uv_connect_cb,
    pub handle: *mut uv_stream_t,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_uv_connect_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_connect_s>(),
        96usize,
        concat!("Size of: ", stringify!(uv_connect_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_connect_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_connect_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).active_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(active_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).handle as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_connect_s>())).queue as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_connect_s),
            "::",
            stringify!(queue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_async_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub async_cb: uv_async_cb,
    pub queue: [*mut ::std::os::raw::c_void; 2usize],
    pub pending: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_async_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_async_s>(),
        96usize,
        concat!("Size of: ", stringify!(uv_async_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_async_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_async_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).async_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(async_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).queue as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_async_s>())).pending as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_async_s),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_signal_s {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub close_cb: uv_close_cb,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub next_closing: *mut uv_handle_t,
    pub flags: ::std::os::raw::c_uint,
    pub signal_cb: uv_signal_cb,
    pub signum: ::std::os::raw::c_int,
    pub tree_entry: uv_signal_s__bindgen_ty_1,
    pub caught_signals: ::std::os::raw::c_uint,
    pub dispatched_signals: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_signal_s__bindgen_ty_1 {
    pub rbe_left: *mut uv_signal_s,
    pub rbe_right: *mut uv_signal_s,
    pub rbe_parent: *mut uv_signal_s,
    pub rbe_color: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uv_signal_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_left as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_right as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_right)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_parent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uv_signal_s__bindgen_ty_1>())).rbe_color as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s__bindgen_ty_1),
            "::",
            stringify!(rbe_color)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_signal_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_signal_s>(),
        120usize,
        concat!("Size of: ", stringify!(uv_signal_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_signal_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_signal_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).close_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(close_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).handle_queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).next_closing as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(next_closing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signal_cb as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signal_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).signum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(signum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).tree_entry as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(tree_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).caught_signals as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(caught_signals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_signal_s>())).dispatched_signals as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_signal_s),
            "::",
            stringify!(dispatched_signals)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uv_loop_s {
    pub data: *mut ::std::os::raw::c_void,
    pub active_handles: ::std::os::raw::c_uint,
    pub handle_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub active_reqs: [*mut ::std::os::raw::c_void; 2usize],
    pub stop_flag: ::std::os::raw::c_uint,
    pub reserved: [*mut ::std::os::raw::c_void; 4usize],
    pub flags: ::std::os::raw::c_ulong,
    pub backend_fd: ::std::os::raw::c_int,
    pub pending_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watcher_queue: [*mut ::std::os::raw::c_void; 2usize],
    pub watchers: *mut *mut uv__io_t,
    pub nwatchers: ::std::os::raw::c_uint,
    pub nfds: ::std::os::raw::c_uint,
    pub wq: [*mut ::std::os::raw::c_void; 2usize],
    pub wq_mutex: uv_mutex_t,
    pub wq_async: uv_async_t,
    pub cloexec_lock: uv_rwlock_t,
    pub closing_handles: *mut uv_handle_t,
    pub process_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub prepare_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub check_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub idle_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_handles: [*mut ::std::os::raw::c_void; 2usize],
    pub async_unused: ::std::option::Option<unsafe extern "C" fn()>,
    pub async_io_watcher: uv__io_t,
    pub async_wfd: ::std::os::raw::c_int,
    pub timer_heap: uv_loop_s__bindgen_ty_1,
    pub timer_counter: u64,
    pub time: u64,
    pub signal_pipefd: [::std::os::raw::c_int; 2usize],
    pub signal_io_watcher: uv__io_t,
    pub child_watcher: uv_signal_t,
    pub emfile_fd: ::std::os::raw::c_int,
    pub inotify_read_watcher: uv__io_t,
    pub inotify_watchers: *mut ::std::os::raw::c_void,
    pub inotify_fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uv_loop_s__bindgen_ty_1 {
    pub min: *mut ::std::os::raw::c_void,
    pub nelts: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_uv_loop_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s__bindgen_ty_1>())).nelts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s__bindgen_ty_1),
            "::",
            stringify!(nelts)
        )
    );
}
#[test]
fn bindgen_test_layout_uv_loop_s() {
    assert_eq!(
        ::std::mem::size_of::<uv_loop_s>(),
        816usize,
        concat!("Size of: ", stringify!(uv_loop_s))
    );
    assert_eq!(
        ::std::mem::align_of::<uv_loop_s>(),
        8usize,
        concat!("Alignment of ", stringify!(uv_loop_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_handles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).handle_queue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(handle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).active_reqs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(active_reqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).stop_flag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(stop_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).backend_fd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(backend_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).pending_queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(pending_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watcher_queue as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watcher_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).watchers as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(watchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nwatchers as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nwatchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).nfds as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_mutex as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).wq_async as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(wq_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).cloexec_lock as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(cloexec_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).closing_handles as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(closing_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).process_handles as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(process_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).prepare_handles as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(prepare_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).check_handles as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(check_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).idle_handles as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(idle_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_handles as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_unused as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_io_watcher as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).async_wfd as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(async_wfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_heap as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).timer_counter as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(timer_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).time as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_pipefd as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_pipefd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).signal_io_watcher as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(signal_io_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).child_watcher as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(child_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).emfile_fd as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(emfile_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).inotify_read_watcher as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(inotify_read_watcher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).inotify_watchers as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(inotify_watchers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uv_loop_s>())).inotify_fd as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(uv_loop_s),
            "::",
            stringify!(inotify_fd)
        )
    );
}
pub const bufmode_t_bm_none: bufmode_t = 19;
pub const bufmode_t_bm_line: bufmode_t = 20;
pub const bufmode_t_bm_block: bufmode_t = 21;
pub const bufmode_t_bm_mem: bufmode_t = 22;
pub type bufmode_t = u32;
pub const bufstate_t_bst_none: bufstate_t = 0;
pub const bufstate_t_bst_rd: bufstate_t = 1;
pub const bufstate_t_bst_wr: bufstate_t = 2;
pub type bufstate_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ios_t {
    pub buf: *mut ::std::os::raw::c_char,
    pub errcode: ::std::os::raw::c_int,
    pub _pad_bm: ::std::os::raw::c_int,
    pub bm: bufmode_t,
    pub state: bufstate_t,
    pub maxsize: i64,
    pub size: i64,
    pub bpos: i64,
    pub ndirty: i64,
    pub fpos: i64,
    pub lineno: usize,
    pub fd: ::std::os::raw::c_long,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub userdata: i64,
    pub local: [::std::os::raw::c_char; 54usize],
}
#[test]
fn bindgen_test_layout_ios_t() {
    assert_eq!(
        ::std::mem::size_of::<ios_t>(),
        152usize,
        concat!("Size of: ", stringify!(ios_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ios_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ios_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).errcode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(errcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>()))._pad_bm as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(_pad_bm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).bm as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ios_t), "::", stringify!(bm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).state as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).maxsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).bpos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(bpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).ndirty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(ndirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).fpos as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(fpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).lineno as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(lineno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).fd as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(ios_t), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).userdata as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ios_t>())).local as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ios_t),
            "::",
            stringify!(local)
        )
    );
}
impl ios_t {
    #[inline]
    pub fn readable(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_readable(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn writable(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_writable(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ownbuf(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ownbuf(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ownfd(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ownfd(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _eof(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__eof(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rereadable(&self) -> ::std::os::raw::c_uchar {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rereadable(&mut self, val: ::std::os::raw::c_uchar) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        readable: ::std::os::raw::c_uchar,
        writable: ::std::os::raw::c_uchar,
        ownbuf: ::std::os::raw::c_uchar,
        ownfd: ::std::os::raw::c_uchar,
        _eof: ::std::os::raw::c_uchar,
        rereadable: ::std::os::raw::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let readable: u8 = unsafe { ::std::mem::transmute(readable) };
            readable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let writable: u8 = unsafe { ::std::mem::transmute(writable) };
            writable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ownbuf: u8 = unsafe { ::std::mem::transmute(ownbuf) };
            ownbuf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ownfd: u8 = unsafe { ::std::mem::transmute(ownfd) };
            ownfd as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let _eof: u8 = unsafe { ::std::mem::transmute(_eof) };
            _eof as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rereadable: u8 = unsafe { ::std::mem::transmute(rereadable) };
            rereadable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_timeval {
    pub sec: i64,
    pub usec: i64,
}
#[test]
fn bindgen_test_layout_jl_timeval() {
    assert_eq!(
        ::std::mem::size_of::<jl_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(jl_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_timeval>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_timeval),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_timeval>())).usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_timeval),
            "::",
            stringify!(usec)
        )
    );
}
extern "C" {
    pub fn jl_gettimeofday(jtv: *mut jl_timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_clock_now() -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htable_t {
    pub size: usize,
    pub table: *mut *mut ::std::os::raw::c_void,
    pub _space: [*mut ::std::os::raw::c_void; 32usize],
}
#[test]
fn bindgen_test_layout_htable_t() {
    assert_eq!(
        ::std::mem::size_of::<htable_t>(),
        272usize,
        concat!("Size of: ", stringify!(htable_t))
    );
    assert_eq!(
        ::std::mem::align_of::<htable_t>(),
        8usize,
        concat!("Alignment of ", stringify!(htable_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htable_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(htable_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htable_t>())).table as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(htable_t),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<htable_t>()))._space as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(htable_t),
            "::",
            stringify!(_space)
        )
    );
}
extern "C" {
    pub fn jl_strtod_c(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn jl_strtof_c(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arraylist_t {
    pub len: usize,
    pub max: usize,
    pub items: *mut *mut ::std::os::raw::c_void,
    pub _space: [*mut ::std::os::raw::c_void; 29usize],
}
#[test]
fn bindgen_test_layout_arraylist_t() {
    assert_eq!(
        ::std::mem::size_of::<arraylist_t>(),
        256usize,
        concat!("Size of: ", stringify!(arraylist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<arraylist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(arraylist_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>())).items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arraylist_t>()))._space as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arraylist_t),
            "::",
            stringify!(_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
pub type jl_taggedvalue_t = _jl_taggedvalue_t;
pub type jl_tls_states_t = _jl_tls_states_t;
pub type jl_ptls_t = *mut jl_tls_states_t;
extern "C" {
    pub fn jl_threadid() -> i16;
}
extern "C" {
    pub fn jl_threading_profile();
}
extern "C" {
    pub fn jl_get_ptls_states() -> jl_ptls_t;
}
extern "C" {
    #[link_name = "\u{1}jl_tls_states"]
    pub static mut jl_tls_states: jl_tls_states_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_mutex_t {
    pub owner: ::std::os::raw::c_ulong,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_jl_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_mutex_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_mutex_t>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_mutex_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_mutex_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_mutex_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_gc_pool_t {
    pub freelist: *mut jl_taggedvalue_t,
    pub newpages: *mut jl_taggedvalue_t,
    pub osize: u16,
}
#[test]
fn bindgen_test_layout_jl_gc_pool_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_gc_pool_t>(),
        24usize,
        concat!("Size of: ", stringify!(jl_gc_pool_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_gc_pool_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_gc_pool_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_pool_t>())).freelist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_pool_t),
            "::",
            stringify!(freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_pool_t>())).newpages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_pool_t),
            "::",
            stringify!(newpages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_pool_t>())).osize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_pool_t),
            "::",
            stringify!(osize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct jl_thread_heap_t {
    pub weak_refs: arraylist_t,
    pub mallocarrays: *mut _mallocarray_t,
    pub mafreelist: *mut _mallocarray_t,
    pub big_objects: *mut _bigval_t,
    pub rem_bindings: arraylist_t,
    pub _remset: [arraylist_t; 2usize],
    pub remset_nptr: ::std::os::raw::c_int,
    pub remset: *mut arraylist_t,
    pub last_remset: *mut arraylist_t,
    pub norm_pools: [jl_gc_pool_t; 41usize],
}
#[test]
fn bindgen_test_layout_jl_thread_heap_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_thread_heap_t>(),
        2056usize,
        concat!("Size of: ", stringify!(jl_thread_heap_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_thread_heap_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_thread_heap_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).weak_refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(weak_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).mallocarrays as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(mallocarrays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).mafreelist as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(mafreelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).big_objects as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(big_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).rem_bindings as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(rem_bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>()))._remset as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(_remset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).remset_nptr as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(remset_nptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).remset as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(remset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).last_remset as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(last_remset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_thread_heap_t>())).norm_pools as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_thread_heap_t),
            "::",
            stringify!(norm_pools)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_gc_mark_data {
    _unused: [u8; 0],
}
pub type jl_gc_mark_data_t = _jl_gc_mark_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct jl_gc_mark_cache_t {
    pub perm_scanned_bytes: usize,
    pub scanned_bytes: usize,
    pub nbig_obj: usize,
    pub big_obj: [*mut ::std::os::raw::c_void; 1024usize],
    pub stack_lock: jl_mutex_t,
    pub pc_stack: *mut *mut ::std::os::raw::c_void,
    pub pc_stack_end: *mut *mut ::std::os::raw::c_void,
    pub data_stack: *mut jl_gc_mark_data_t,
}
#[test]
fn bindgen_test_layout_jl_gc_mark_cache_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_gc_mark_cache_t>(),
        8256usize,
        concat!("Size of: ", stringify!(jl_gc_mark_cache_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_gc_mark_cache_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_gc_mark_cache_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).perm_scanned_bytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(perm_scanned_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).scanned_bytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(scanned_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).nbig_obj as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(nbig_obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).big_obj as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(big_obj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).stack_lock as *const _ as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(stack_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).pc_stack as *const _ as usize },
        8232usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(pc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).pc_stack_end as *const _ as usize },
        8240usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(pc_stack_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_gc_mark_cache_t>())).data_stack as *const _ as usize },
        8248usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_gc_mark_cache_t),
            "::",
            stringify!(data_stack)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_tls_states_t {
    pub pgcstack: *mut _jl_gcframe_t,
    pub world_age: usize,
    pub exception_in_transit: *mut _jl_value_t,
    pub safepoint: *mut usize,
    pub gc_state: i8,
    pub in_finalizer: i8,
    pub disable_gc: i8,
    pub defer_signal: sig_atomic_t,
    pub current_module: *mut _jl_module_t,
    pub current_task: *mut _jl_task_t,
    pub root_task: *mut _jl_task_t,
    pub stackbase: *mut ::std::os::raw::c_void,
    pub stack_lo: *mut ::std::os::raw::c_char,
    pub stack_hi: *mut ::std::os::raw::c_char,
    pub base_ctx: sigjmp_buf,
    pub safe_restore: *mut sigjmp_buf,
    pub tid: i16,
    pub bt_size: usize,
    pub bt_data: *mut usize,
    pub signal_request: sig_atomic_t,
    pub io_wait: sig_atomic_t,
    pub heap: jl_thread_heap_t,
    pub system_id: pthread_t,
    pub signal_stack: *mut ::std::os::raw::c_void,
    pub in_pure_callback: ::std::os::raw::c_int,
    pub finalizers_inhibited: ::std::os::raw::c_int,
    pub finalizers: arraylist_t,
    pub gc_cache: jl_gc_mark_cache_t,
}
#[test]
fn bindgen_test_layout__jl_tls_states_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_tls_states_t>(),
        10920usize,
        concat!("Size of: ", stringify!(_jl_tls_states_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_tls_states_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_tls_states_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).pgcstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(pgcstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).world_age as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(world_age)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_tls_states_t>())).exception_in_transit as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(exception_in_transit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).safepoint as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(safepoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).gc_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(gc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).in_finalizer as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(in_finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).disable_gc as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(disable_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).defer_signal as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(defer_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).current_module as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(current_module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).current_task as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(current_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).root_task as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(root_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).stackbase as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(stackbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).stack_lo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(stack_lo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).stack_hi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(stack_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).base_ctx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(base_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).safe_restore as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(safe_restore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).tid as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).bt_size as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(bt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).bt_data as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(bt_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).signal_request as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(signal_request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).io_wait as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(io_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).heap as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).system_id as *const _ as usize },
        2384usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(system_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).signal_stack as *const _ as usize },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(signal_stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_tls_states_t>())).in_pure_callback as *const _ as usize
        },
        2400usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(in_pure_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_tls_states_t>())).finalizers_inhibited as *const _ as usize
        },
        2404usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(finalizers_inhibited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).finalizers as *const _ as usize },
        2408usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(finalizers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_tls_states_t>())).gc_cache as *const _ as usize },
        2664usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_tls_states_t),
            "::",
            stringify!(gc_cache)
        )
    );
}
extern "C" {
    pub fn jl_cpu_pause();
}
extern "C" {
    pub fn jl_cpu_wake();
}
extern "C" {
    pub fn jl_gc_safepoint();
}
extern "C" {
    pub fn jl_gc_enable_finalizers(ptls: jl_ptls_t, on: ::std::os::raw::c_int);
}
pub type jl_value_t = _jl_value_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_taggedvalue_bits {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout__jl_taggedvalue_bits() {
    assert_eq!(
        ::std::mem::size_of::<_jl_taggedvalue_bits>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_taggedvalue_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_taggedvalue_bits>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_taggedvalue_bits))
    );
}
impl _jl_taggedvalue_bits {
    #[inline]
    pub fn gc(&self) -> usize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_gc(&mut self, val: usize) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gc: usize) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let gc: u64 = unsafe { ::std::mem::transmute(gc) };
            gc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_taggedvalue_t {
    pub __bindgen_anon_1: _jl_taggedvalue_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _jl_taggedvalue_t__bindgen_ty_1 {
    pub header: usize,
    pub next: *mut jl_taggedvalue_t,
    pub type_: *mut jl_value_t,
    pub bits: _jl_taggedvalue_bits,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__jl_taggedvalue_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_jl_taggedvalue_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_taggedvalue_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_taggedvalue_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_taggedvalue_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_taggedvalue_t__bindgen_ty_1>())).bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_taggedvalue_t__bindgen_ty_1),
            "::",
            stringify!(bits)
        )
    );
}
#[test]
fn bindgen_test_layout__jl_taggedvalue_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_taggedvalue_t>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_taggedvalue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_taggedvalue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_taggedvalue_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_sym_t {
    pub left: *mut _jl_sym_t,
    pub right: *mut _jl_sym_t,
    pub hash: usize,
}
#[test]
fn bindgen_test_layout__jl_sym_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_sym_t>(),
        24usize,
        concat!("Size of: ", stringify!(_jl_sym_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_sym_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_sym_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_sym_t>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_sym_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_sym_t>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_sym_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_sym_t>())).hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_sym_t),
            "::",
            stringify!(hash)
        )
    );
}
pub type jl_sym_t = _jl_sym_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_ssavalue_t {
    pub id: isize,
}
#[test]
fn bindgen_test_layout__jl_ssavalue_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_ssavalue_t>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_ssavalue_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_ssavalue_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_ssavalue_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_ssavalue_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_ssavalue_t),
            "::",
            stringify!(id)
        )
    );
}
pub type jl_ssavalue_t = _jl_ssavalue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_svec_t {
    pub length: usize,
}
#[test]
fn bindgen_test_layout_jl_svec_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_svec_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_svec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_svec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_svec_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_svec_t>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_svec_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_array_flags_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_jl_array_flags_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_array_flags_t>(),
        2usize,
        concat!("Size of: ", stringify!(jl_array_flags_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_array_flags_t>(),
        2usize,
        concat!("Alignment of ", stringify!(jl_array_flags_t))
    );
}
impl jl_array_flags_t {
    #[inline]
    pub fn how(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_how(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ndims(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_ndims(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn pooled(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_pooled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ptrarray(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ptrarray(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isshared(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isshared(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isaligned(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isaligned(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        how: u16,
        ndims: u16,
        pooled: u16,
        ptrarray: u16,
        isshared: u16,
        isaligned: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let how: u16 = unsafe { ::std::mem::transmute(how) };
            how as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let ndims: u16 = unsafe { ::std::mem::transmute(ndims) };
            ndims as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let pooled: u16 = unsafe { ::std::mem::transmute(pooled) };
            pooled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let ptrarray: u16 = unsafe { ::std::mem::transmute(ptrarray) };
            ptrarray as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let isshared: u16 = unsafe { ::std::mem::transmute(isshared) };
            isshared as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let isaligned: u16 = unsafe { ::std::mem::transmute(isaligned) };
            isaligned as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct jl_array_t {
    pub data: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub flags: jl_array_flags_t,
    pub elsize: u16,
    pub offset: u32,
    pub nrows: usize,
    pub __bindgen_anon_1: jl_array_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union jl_array_t__bindgen_ty_1 {
    pub maxsize: usize,
    pub ncols: usize,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_jl_array_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<jl_array_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(jl_array_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_array_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_array_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_array_t__bindgen_ty_1>())).maxsize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t__bindgen_ty_1),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t__bindgen_ty_1>())).ncols as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t__bindgen_ty_1),
            "::",
            stringify!(ncols)
        )
    );
}
#[test]
fn bindgen_test_layout_jl_array_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_array_t>(),
        40usize,
        concat!("Size of: ", stringify!(jl_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_array_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).elsize as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(elsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).offset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_array_t>())).nrows as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_array_t),
            "::",
            stringify!(nrows)
        )
    );
}
pub type jl_tupletype_t = _jl_datatype_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union jl_typemap_t {
    pub node: *mut _jl_typemap_level_t,
    pub leaf: *mut _jl_typemap_entry_t,
    pub unknown: *mut _jl_value_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_jl_typemap_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_typemap_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_typemap_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_typemap_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_typemap_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typemap_t>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typemap_t),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typemap_t>())).leaf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typemap_t),
            "::",
            stringify!(leaf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typemap_t>())).unknown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typemap_t),
            "::",
            stringify!(unknown)
        )
    );
}
pub type jl_call_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _jl_method_instance_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t,
>;
pub type jl_callptr_t = jl_call_t;
extern "C" {
    pub fn jl_fptr_trampoline(
        arg1: *mut _jl_method_instance_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_fptr_args(
        arg1: *mut _jl_method_instance_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t;
}
pub type jl_fptr_args_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut jl_value_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t,
>;
extern "C" {
    pub fn jl_fptr_const_return(
        arg1: *mut _jl_method_instance_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_fptr_sparam(
        arg1: *mut _jl_method_instance_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t;
}
pub type jl_fptr_sparam_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut jl_svec_t,
        arg2: *mut jl_value_t,
        arg3: *mut *mut jl_value_t,
        arg4: u32,
    ) -> *mut jl_value_t,
>;
extern "C" {
    pub fn jl_fptr_interpret_call(
        arg1: *mut _jl_method_instance_t,
        arg2: *mut *mut jl_value_t,
        arg3: u32,
    ) -> *mut jl_value_t;
}
pub type jl_fptr_interpret_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _jl_method_instance_t,
        arg2: *mut jl_value_t,
        arg3: *mut *mut jl_value_t,
        arg4: u32,
        arg5: *mut jl_svec_t,
    ) -> *mut jl_value_t,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union jl_generic_specptr_t {
    pub fptr: *mut ::std::os::raw::c_void,
    pub fptr1: jl_fptr_args_t,
    pub fptr3: jl_fptr_sparam_t,
    pub fptr4: jl_fptr_interpret_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_jl_generic_specptr_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_generic_specptr_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_generic_specptr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_generic_specptr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_generic_specptr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_generic_specptr_t>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_generic_specptr_t),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_generic_specptr_t>())).fptr1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_generic_specptr_t),
            "::",
            stringify!(fptr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_generic_specptr_t>())).fptr3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_generic_specptr_t),
            "::",
            stringify!(fptr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_generic_specptr_t>())).fptr4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_generic_specptr_t),
            "::",
            stringify!(fptr4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_llvm_functions_t {
    pub functionObject: *const ::std::os::raw::c_char,
    pub specFunctionObject: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__jl_llvm_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_llvm_functions_t>(),
        16usize,
        concat!("Size of: ", stringify!(_jl_llvm_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_llvm_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_llvm_functions_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_llvm_functions_t>())).functionObject as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_llvm_functions_t),
            "::",
            stringify!(functionObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_llvm_functions_t>())).specFunctionObject as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_llvm_functions_t),
            "::",
            stringify!(specFunctionObject)
        )
    );
}
pub type jl_llvm_functions_t = _jl_llvm_functions_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_code_info_t {
    pub code: *mut jl_array_t,
    pub codelocs: *mut jl_value_t,
    pub method_for_inference_limit_heuristics: *mut jl_value_t,
    pub ssavaluetypes: *mut jl_value_t,
    pub linetable: *mut jl_value_t,
    pub ssaflags: *mut jl_array_t,
    pub slotflags: *mut jl_array_t,
    pub slotnames: *mut jl_array_t,
    pub inferred: u8,
    pub inlineable: u8,
    pub propagate_inbounds: u8,
    pub pure_: u8,
}
#[test]
fn bindgen_test_layout__jl_code_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_code_info_t>(),
        72usize,
        concat!("Size of: ", stringify!(_jl_code_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_code_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_code_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).codelocs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(codelocs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_code_info_t>())).method_for_inference_limit_heuristics
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(method_for_inference_limit_heuristics)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).ssavaluetypes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(ssavaluetypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).linetable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(linetable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).ssaflags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(ssaflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).slotflags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(slotflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).slotnames as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(slotnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).inferred as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(inferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).inlineable as *const _ as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(inlineable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_code_info_t>())).propagate_inbounds as *const _ as usize
        },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(propagate_inbounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_code_info_t>())).pure_ as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_code_info_t),
            "::",
            stringify!(pure_)
        )
    );
}
pub type jl_code_info_t = _jl_code_info_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_method_t {
    pub name: *mut jl_sym_t,
    pub module: *mut _jl_module_t,
    pub file: *mut jl_sym_t,
    pub line: i32,
    pub sig: *mut jl_value_t,
    pub min_world: usize,
    pub max_world: usize,
    pub ambig: *mut jl_value_t,
    pub specializations: jl_typemap_t,
    pub sparam_syms: *mut jl_svec_t,
    pub source: *mut jl_value_t,
    pub unspecialized: *mut _jl_method_instance_t,
    pub generator: *mut jl_value_t,
    pub roots: *mut jl_array_t,
    pub invokes: jl_typemap_t,
    pub nargs: i32,
    pub called: i32,
    pub nospecialize: i32,
    pub isva: u8,
    pub pure_: u8,
    pub traced: u8,
    pub writelock: jl_mutex_t,
}
#[test]
fn bindgen_test_layout__jl_method_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_method_t>(),
        152usize,
        concat!("Size of: ", stringify!(_jl_method_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_method_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_method_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).module as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).line as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).sig as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).min_world as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(min_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).max_world as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(max_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).ambig as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(ambig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).specializations as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(specializations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).sparam_syms as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(sparam_syms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).source as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).unspecialized as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(unspecialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).generator as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(generator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).roots as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(roots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).invokes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(invokes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).nargs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).called as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(called)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).nospecialize as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(nospecialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).isva as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(isva)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).pure_ as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(pure_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).traced as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(traced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_t>())).writelock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_t),
            "::",
            stringify!(writelock)
        )
    );
}
pub type jl_method_t = _jl_method_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_method_instance_t {
    pub def: _jl_method_instance_t__bindgen_ty_1,
    pub specTypes: *mut jl_value_t,
    pub rettype: *mut jl_value_t,
    pub sparam_vals: *mut jl_svec_t,
    pub backedges: *mut jl_array_t,
    pub inferred: *mut jl_value_t,
    pub inferred_const: *mut jl_value_t,
    pub min_world: usize,
    pub max_world: usize,
    pub inInference: u8,
    pub compile_traced: u8,
    pub invoke: jl_callptr_t,
    pub specptr: jl_generic_specptr_t,
    pub functionObjectsDecls: jl_llvm_functions_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _jl_method_instance_t__bindgen_ty_1 {
    pub value: *mut jl_value_t,
    pub module: *mut _jl_module_t,
    pub method: *mut jl_method_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__jl_method_instance_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_jl_method_instance_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_method_instance_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_method_instance_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_jl_method_instance_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t__bindgen_ty_1>())).value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t__bindgen_ty_1>())).module as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t__bindgen_ty_1),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t__bindgen_ty_1>())).method as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t__bindgen_ty_1),
            "::",
            stringify!(method)
        )
    );
}
#[test]
fn bindgen_test_layout__jl_method_instance_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_method_instance_t>(),
        112usize,
        concat!("Size of: ", stringify!(_jl_method_instance_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_method_instance_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_method_instance_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).def as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).specTypes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(specTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).rettype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(rettype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).sparam_vals as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(sparam_vals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).backedges as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(backedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).inferred as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(inferred)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).inferred_const as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(inferred_const)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).min_world as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(min_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).max_world as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(max_world)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).inInference as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(inInference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).compile_traced as *const _ as usize
        },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(compile_traced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).invoke as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_method_instance_t>())).specptr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(specptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_method_instance_t>())).functionObjectsDecls as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_method_instance_t),
            "::",
            stringify!(functionObjectsDecls)
        )
    );
}
pub type jl_method_instance_t = _jl_method_instance_t;
pub type jl_function_t = jl_value_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_tvar_t {
    pub name: *mut jl_sym_t,
    pub lb: *mut jl_value_t,
    pub ub: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_tvar_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_tvar_t>(),
        24usize,
        concat!("Size of: ", stringify!(jl_tvar_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_tvar_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_tvar_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_tvar_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_tvar_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_tvar_t>())).lb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_tvar_t),
            "::",
            stringify!(lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_tvar_t>())).ub as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_tvar_t),
            "::",
            stringify!(ub)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_unionall_t {
    pub var: *mut jl_tvar_t,
    pub body: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_unionall_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_unionall_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_unionall_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_unionall_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_unionall_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_unionall_t>())).var as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_unionall_t),
            "::",
            stringify!(var)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_unionall_t>())).body as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_unionall_t),
            "::",
            stringify!(body)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_typename_t {
    pub name: *mut jl_sym_t,
    pub module: *mut _jl_module_t,
    pub names: *mut jl_svec_t,
    pub wrapper: *mut jl_value_t,
    pub cache: *mut jl_svec_t,
    pub linearcache: *mut jl_svec_t,
    pub hash: isize,
    pub mt: *mut _jl_methtable_t,
}
#[test]
fn bindgen_test_layout_jl_typename_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_typename_t>(),
        64usize,
        concat!("Size of: ", stringify!(jl_typename_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_typename_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_typename_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).module as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).names as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).wrapper as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(wrapper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).cache as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).linearcache as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(linearcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).hash as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_typename_t>())).mt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_typename_t),
            "::",
            stringify!(mt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_uniontype_t {
    pub a: *mut jl_value_t,
    pub b: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_uniontype_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_uniontype_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_uniontype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_uniontype_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_uniontype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uniontype_t>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uniontype_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uniontype_t>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uniontype_t),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_fielddesc8_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub offset: u8,
}
#[test]
fn bindgen_test_layout_jl_fielddesc8_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_fielddesc8_t>(),
        2usize,
        concat!("Size of: ", stringify!(jl_fielddesc8_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_fielddesc8_t>(),
        1usize,
        concat!("Alignment of ", stringify!(jl_fielddesc8_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_fielddesc8_t>())).offset as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_fielddesc8_t),
            "::",
            stringify!(offset)
        )
    );
}
impl jl_fielddesc8_t {
    #[inline]
    pub fn isptr(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isptr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isptr: u8, size: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isptr: u8 = unsafe { ::std::mem::transmute(isptr) };
            isptr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let size: u8 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_fielddesc16_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub offset: u16,
}
#[test]
fn bindgen_test_layout_jl_fielddesc16_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_fielddesc16_t>(),
        4usize,
        concat!("Size of: ", stringify!(jl_fielddesc16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_fielddesc16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(jl_fielddesc16_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_fielddesc16_t>())).offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_fielddesc16_t),
            "::",
            stringify!(offset)
        )
    );
}
impl jl_fielddesc16_t {
    #[inline]
    pub fn isptr(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isptr(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isptr: u16, size: u16) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isptr: u16 = unsafe { ::std::mem::transmute(isptr) };
            isptr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let size: u16 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_fielddesc32_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_jl_fielddesc32_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_fielddesc32_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_fielddesc32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_fielddesc32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(jl_fielddesc32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_fielddesc32_t>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_fielddesc32_t),
            "::",
            stringify!(offset)
        )
    );
}
impl jl_fielddesc32_t {
    #[inline]
    pub fn isptr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isptr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isptr: u32, size: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isptr: u32 = unsafe { ::std::mem::transmute(isptr) };
            isptr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_datatype_layout_t {
    pub nfields: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_jl_datatype_layout_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_datatype_layout_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_datatype_layout_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_datatype_layout_t>(),
        4usize,
        concat!("Alignment of ", stringify!(jl_datatype_layout_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_datatype_layout_t>())).nfields as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_datatype_layout_t),
            "::",
            stringify!(nfields)
        )
    );
}
impl jl_datatype_layout_t {
    #[inline]
    pub fn alignment(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_alignment(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn haspadding(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_haspadding(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn npointers(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_npointers(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn fielddesc_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fielddesc_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        alignment: u32,
        haspadding: u32,
        npointers: u32,
        fielddesc_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let alignment: u32 = unsafe { ::std::mem::transmute(alignment) };
            alignment as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let haspadding: u32 = unsafe { ::std::mem::transmute(haspadding) };
            haspadding as u64
        });
        __bindgen_bitfield_unit.set(10usize, 20u8, {
            let npointers: u32 = unsafe { ::std::mem::transmute(npointers) };
            npointers as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let fielddesc_type: u32 = unsafe { ::std::mem::transmute(fielddesc_type) };
            fielddesc_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_datatype_t {
    pub name: *mut jl_typename_t,
    pub super_: *mut _jl_datatype_t,
    pub parameters: *mut jl_svec_t,
    pub types: *mut jl_svec_t,
    pub names: *mut jl_svec_t,
    pub instance: *mut jl_value_t,
    pub layout: *const jl_datatype_layout_t,
    pub size: i32,
    pub ninitialized: i32,
    pub uid: u32,
    pub abstract_: u8,
    pub mutabl: u8,
    pub hasfreetypevars: u8,
    pub isconcretetype: u8,
    pub isdispatchtuple: u8,
    pub isbitstype: u8,
    pub zeroinit: u8,
    pub isinlinealloc: u8,
    pub struct_decl: *mut ::std::os::raw::c_void,
    pub ditype: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__jl_datatype_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_datatype_t>(),
        96usize,
        concat!("Size of: ", stringify!(_jl_datatype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_datatype_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_datatype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).super_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(super_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).parameters as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).names as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).instance as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).layout as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).ninitialized as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(ninitialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).uid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).abstract_ as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(abstract_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).mutabl as *const _ as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(mutabl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).hasfreetypevars as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(hasfreetypevars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isconcretetype as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isconcretetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isdispatchtuple as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isdispatchtuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isbitstype as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isbitstype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).zeroinit as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(zeroinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).isinlinealloc as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(isinlinealloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).struct_decl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(struct_decl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_datatype_t>())).ditype as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_datatype_t),
            "::",
            stringify!(ditype)
        )
    );
}
pub type jl_datatype_t = _jl_datatype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_weakref_t {
    pub value: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_weakref_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_weakref_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_weakref_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_weakref_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_weakref_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_weakref_t>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_weakref_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_binding_t {
    pub name: *mut jl_sym_t,
    pub value: *mut jl_value_t,
    pub globalref: *mut jl_value_t,
    pub owner: *mut _jl_module_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_jl_binding_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_binding_t>(),
        40usize,
        concat!("Size of: ", stringify!(jl_binding_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_binding_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_binding_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).globalref as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(globalref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_binding_t>())).owner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_binding_t),
            "::",
            stringify!(owner)
        )
    );
}
impl jl_binding_t {
    #[inline]
    pub fn constp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_constp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exportp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exportp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn imported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_imported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deprecated(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_deprecated(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        constp: u8,
        exportp: u8,
        imported: u8,
        deprecated: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let constp: u8 = unsafe { ::std::mem::transmute(constp) };
            constp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let exportp: u8 = unsafe { ::std::mem::transmute(exportp) };
            exportp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let imported: u8 = unsafe { ::std::mem::transmute(imported) };
            imported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let deprecated: u8 = unsafe { ::std::mem::transmute(deprecated) };
            deprecated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_uuid_t {
    pub hi: u64,
    pub lo: u64,
}
#[test]
fn bindgen_test_layout_jl_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_uuid_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uuid_t>())).hi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uuid_t),
            "::",
            stringify!(hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uuid_t>())).lo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uuid_t),
            "::",
            stringify!(lo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_module_t {
    pub name: *mut jl_sym_t,
    pub parent: *mut _jl_module_t,
    pub bindings: htable_t,
    pub usings: arraylist_t,
    pub build_id: u64,
    pub uuid: jl_uuid_t,
    pub primary_world: usize,
    pub counter: u32,
    pub nospecialize: i32,
    pub istopmod: u8,
}
#[test]
fn bindgen_test_layout__jl_module_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_module_t>(),
        592usize,
        concat!("Size of: ", stringify!(_jl_module_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_module_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_module_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).bindings as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).usings as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(usings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).build_id as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(build_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).uuid as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).primary_world as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(primary_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).counter as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).nospecialize as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(nospecialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_module_t>())).istopmod as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_module_t),
            "::",
            stringify!(istopmod)
        )
    );
}
pub type jl_module_t = _jl_module_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_typemap_entry_t {
    pub next: *mut _jl_typemap_entry_t,
    pub sig: *mut jl_tupletype_t,
    pub simplesig: *mut jl_tupletype_t,
    pub guardsigs: *mut jl_svec_t,
    pub min_world: usize,
    pub max_world: usize,
    pub func: _jl_typemap_entry_t__bindgen_ty_1,
    pub isleafsig: i8,
    pub issimplesig: i8,
    pub va: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _jl_typemap_entry_t__bindgen_ty_1 {
    pub value: *mut jl_value_t,
    pub linfo: *mut jl_method_instance_t,
    pub method: *mut jl_method_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__jl_typemap_entry_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_jl_typemap_entry_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_jl_typemap_entry_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_typemap_entry_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_typemap_entry_t__bindgen_ty_1>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_typemap_entry_t__bindgen_ty_1>())).linfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1),
            "::",
            stringify!(linfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_typemap_entry_t__bindgen_ty_1>())).method as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t__bindgen_ty_1),
            "::",
            stringify!(method)
        )
    );
}
#[test]
fn bindgen_test_layout__jl_typemap_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_typemap_entry_t>(),
        64usize,
        concat!("Size of: ", stringify!(_jl_typemap_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_typemap_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_typemap_entry_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).sig as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).simplesig as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(simplesig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).guardsigs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(guardsigs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).min_world as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(min_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).max_world as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(max_world)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).isleafsig as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(isleafsig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).issimplesig as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(issimplesig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_entry_t>())).va as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_entry_t),
            "::",
            stringify!(va)
        )
    );
}
pub type jl_typemap_entry_t = _jl_typemap_entry_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_ordereddict_t {
    pub indices: *mut jl_array_t,
    pub values: *mut jl_array_t,
}
#[test]
fn bindgen_test_layout_jl_ordereddict_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_ordereddict_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_ordereddict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_ordereddict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_ordereddict_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_ordereddict_t>())).indices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_ordereddict_t),
            "::",
            stringify!(indices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_ordereddict_t>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_ordereddict_t),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_typemap_level_t {
    pub arg1: jl_ordereddict_t,
    pub targ: jl_ordereddict_t,
    pub linear: *mut jl_typemap_entry_t,
    pub any: jl_typemap_t,
    pub key: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout__jl_typemap_level_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_typemap_level_t>(),
        56usize,
        concat!("Size of: ", stringify!(_jl_typemap_level_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_typemap_level_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_typemap_level_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).arg1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).targ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(targ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).linear as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).any as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(any)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_typemap_level_t>())).key as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_typemap_level_t),
            "::",
            stringify!(key)
        )
    );
}
pub type jl_typemap_level_t = _jl_typemap_level_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _jl_methtable_t {
    pub name: *mut jl_sym_t,
    pub defs: jl_typemap_t,
    pub cache: jl_typemap_t,
    pub max_args: isize,
    pub kwsorter: *mut jl_value_t,
    pub module: *mut jl_module_t,
    pub backedges: *mut jl_array_t,
    pub writelock: jl_mutex_t,
}
#[test]
fn bindgen_test_layout__jl_methtable_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_methtable_t>(),
        72usize,
        concat!("Size of: ", stringify!(_jl_methtable_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_methtable_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_methtable_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).defs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(defs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).cache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).max_args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(max_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).kwsorter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(kwsorter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).module as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).backedges as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(backedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).writelock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(writelock)
        )
    );
}
pub type jl_methtable_t = _jl_methtable_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_expr_t {
    pub head: *mut jl_sym_t,
    pub args: *mut jl_array_t,
}
#[test]
fn bindgen_test_layout_jl_expr_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_expr_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_expr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_expr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_expr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_expr_t>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_expr_t),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_expr_t>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_expr_t),
            "::",
            stringify!(args)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}jl_typeofbottom_type"]
    pub static mut jl_typeofbottom_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_datatype_type"]
    pub static mut jl_datatype_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_uniontype_type"]
    pub static mut jl_uniontype_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_unionall_type"]
    pub static mut jl_unionall_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_tvar_type"]
    pub static mut jl_tvar_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_any_type"]
    pub static mut jl_any_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_type_type"]
    pub static mut jl_type_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_typetype_type"]
    pub static mut jl_typetype_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_typename_type"]
    pub static mut jl_typename_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_type_typename"]
    pub static mut jl_type_typename: *mut jl_typename_t;
}
extern "C" {
    #[link_name = "\u{1}jl_sym_type"]
    pub static mut jl_sym_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_symbol_type"]
    pub static mut jl_symbol_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_ssavalue_type"]
    pub static mut jl_ssavalue_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_abstractslot_type"]
    pub static mut jl_abstractslot_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_slotnumber_type"]
    pub static mut jl_slotnumber_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_typedslot_type"]
    pub static mut jl_typedslot_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_simplevector_type"]
    pub static mut jl_simplevector_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_tuple_typename"]
    pub static mut jl_tuple_typename: *mut jl_typename_t;
}
extern "C" {
    #[link_name = "\u{1}jl_vecelement_typename"]
    pub static mut jl_vecelement_typename: *mut jl_typename_t;
}
extern "C" {
    #[link_name = "\u{1}jl_anytuple_type"]
    pub static mut jl_anytuple_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_emptytuple_type"]
    pub static mut jl_emptytuple_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_anytuple_type_type"]
    pub static mut jl_anytuple_type_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_vararg_type"]
    pub static mut jl_vararg_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_vararg_typename"]
    pub static mut jl_vararg_typename: *mut jl_typename_t;
}
extern "C" {
    #[link_name = "\u{1}jl_task_type"]
    pub static mut jl_task_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_function_type"]
    pub static mut jl_function_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_builtin_type"]
    pub static mut jl_builtin_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_bottom_type"]
    pub static mut jl_bottom_type: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_method_instance_type"]
    pub static mut jl_method_instance_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_code_info_type"]
    pub static mut jl_code_info_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_method_type"]
    pub static mut jl_method_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_module_type"]
    pub static mut jl_module_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_abstractarray_type"]
    pub static mut jl_abstractarray_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_densearray_type"]
    pub static mut jl_densearray_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_array_type"]
    pub static mut jl_array_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_array_typename"]
    pub static mut jl_array_typename: *mut jl_typename_t;
}
extern "C" {
    #[link_name = "\u{1}jl_weakref_type"]
    pub static mut jl_weakref_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_abstractstring_type"]
    pub static mut jl_abstractstring_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_string_type"]
    pub static mut jl_string_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_errorexception_type"]
    pub static mut jl_errorexception_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_argumenterror_type"]
    pub static mut jl_argumenterror_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_loaderror_type"]
    pub static mut jl_loaderror_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_initerror_type"]
    pub static mut jl_initerror_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_typeerror_type"]
    pub static mut jl_typeerror_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_methoderror_type"]
    pub static mut jl_methoderror_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_undefvarerror_type"]
    pub static mut jl_undefvarerror_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_lineinfonode_type"]
    pub static mut jl_lineinfonode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_stackovf_exception"]
    pub static mut jl_stackovf_exception: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_memory_exception"]
    pub static mut jl_memory_exception: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_readonlymemory_exception"]
    pub static mut jl_readonlymemory_exception: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_diverror_exception"]
    pub static mut jl_diverror_exception: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_undefref_exception"]
    pub static mut jl_undefref_exception: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_interrupt_exception"]
    pub static mut jl_interrupt_exception: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_boundserror_type"]
    pub static mut jl_boundserror_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_an_empty_vec_any"]
    pub static mut jl_an_empty_vec_any: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_bool_type"]
    pub static mut jl_bool_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_char_type"]
    pub static mut jl_char_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_int8_type"]
    pub static mut jl_int8_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_uint8_type"]
    pub static mut jl_uint8_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_int16_type"]
    pub static mut jl_int16_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_uint16_type"]
    pub static mut jl_uint16_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_int32_type"]
    pub static mut jl_int32_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_uint32_type"]
    pub static mut jl_uint32_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_int64_type"]
    pub static mut jl_int64_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_uint64_type"]
    pub static mut jl_uint64_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_float16_type"]
    pub static mut jl_float16_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_float32_type"]
    pub static mut jl_float32_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_float64_type"]
    pub static mut jl_float64_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_floatingpoint_type"]
    pub static mut jl_floatingpoint_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_number_type"]
    pub static mut jl_number_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_void_type"]
    pub static mut jl_void_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_signed_type"]
    pub static mut jl_signed_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_voidpointer_type"]
    pub static mut jl_voidpointer_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_pointer_type"]
    pub static mut jl_pointer_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_ref_type"]
    pub static mut jl_ref_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_pointer_typename"]
    pub static mut jl_pointer_typename: *mut jl_typename_t;
}
extern "C" {
    #[link_name = "\u{1}jl_namedtuple_typename"]
    pub static mut jl_namedtuple_typename: *mut jl_typename_t;
}
extern "C" {
    #[link_name = "\u{1}jl_namedtuple_type"]
    pub static mut jl_namedtuple_type: *mut jl_unionall_t;
}
extern "C" {
    #[link_name = "\u{1}jl_array_uint8_type"]
    pub static mut jl_array_uint8_type: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_array_any_type"]
    pub static mut jl_array_any_type: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_array_symbol_type"]
    pub static mut jl_array_symbol_type: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_array_int32_type"]
    pub static mut jl_array_int32_type: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_expr_type"]
    pub static mut jl_expr_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_globalref_type"]
    pub static mut jl_globalref_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_linenumbernode_type"]
    pub static mut jl_linenumbernode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_gotonode_type"]
    pub static mut jl_gotonode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_phinode_type"]
    pub static mut jl_phinode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_pinode_type"]
    pub static mut jl_pinode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_phicnode_type"]
    pub static mut jl_phicnode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_upsilonnode_type"]
    pub static mut jl_upsilonnode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_quotenode_type"]
    pub static mut jl_quotenode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_newvarnode_type"]
    pub static mut jl_newvarnode_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_intrinsic_type"]
    pub static mut jl_intrinsic_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_methtable_type"]
    pub static mut jl_methtable_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_typemap_level_type"]
    pub static mut jl_typemap_level_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_typemap_entry_type"]
    pub static mut jl_typemap_entry_type: *mut jl_datatype_t;
}
extern "C" {
    #[link_name = "\u{1}jl_emptysvec"]
    pub static mut jl_emptysvec: *mut jl_svec_t;
}
extern "C" {
    #[link_name = "\u{1}jl_emptytuple"]
    pub static mut jl_emptytuple: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_true"]
    pub static mut jl_true: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_false"]
    pub static mut jl_false: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_nothing"]
    pub static mut jl_nothing: *mut jl_value_t;
}
extern "C" {
    #[link_name = "\u{1}jl_incomplete_sym"]
    pub static mut jl_incomplete_sym: *mut jl_sym_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_gcframe_t {
    pub nroots: usize,
    pub prev: *mut _jl_gcframe_t,
}
#[test]
fn bindgen_test_layout__jl_gcframe_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_gcframe_t>(),
        16usize,
        concat!("Size of: ", stringify!(_jl_gcframe_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_gcframe_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_gcframe_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_gcframe_t>())).nroots as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_gcframe_t),
            "::",
            stringify!(nroots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_gcframe_t>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_gcframe_t),
            "::",
            stringify!(prev)
        )
    );
}
pub type jl_gcframe_t = _jl_gcframe_t;
extern "C" {
    pub fn jl_gc_enable(on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_gc_is_enabled() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_gc_total_bytes() -> i64;
}
extern "C" {
    pub fn jl_gc_total_hrtime() -> u64;
}
extern "C" {
    pub fn jl_gc_diff_total_bytes() -> i64;
}
extern "C" {
    pub fn jl_gc_collect(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_gc_add_finalizer(v: *mut jl_value_t, f: *mut jl_function_t);
}
extern "C" {
    pub fn jl_finalize(o: *mut jl_value_t);
}
extern "C" {
    pub fn jl_gc_new_weakref(value: *mut jl_value_t) -> *mut jl_weakref_t;
}
extern "C" {
    pub fn jl_gc_alloc_0w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_alloc_1w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_alloc_2w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_alloc_3w() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_allocobj(sz: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_gc_use(a: *mut jl_value_t);
}
extern "C" {
    pub fn jl_clear_malloc_data();
}
extern "C" {
    pub fn jl_gc_queue_root(root: *mut jl_value_t);
}
extern "C" {
    pub fn jl_gc_managed_malloc(sz: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_gc_managed_realloc(
        d: *mut ::std::os::raw::c_void,
        sz: usize,
        oldsz: usize,
        isaligned: ::std::os::raw::c_int,
        owner: *mut jl_value_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_array_typetagdata(a: *mut jl_array_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_subtype(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_egal(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_object_id(v: *mut jl_value_t) -> usize;
}
extern "C" {
    pub fn jl_has_free_typevars(v: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_has_typevar(t: *mut jl_value_t, v: *mut jl_tvar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_has_typevar_from_unionall(
        t: *mut jl_value_t,
        ua: *mut jl_unionall_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_subtype_env_size(t: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_subtype_env(
        x: *mut jl_value_t,
        y: *mut jl_value_t,
        env: *mut *mut jl_value_t,
        envsz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_isa(a: *mut jl_value_t, t: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_types_equal(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_not_broken_subtype(
        a: *mut jl_value_t,
        b: *mut jl_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_type_union(ts: *mut *mut jl_value_t, n: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_type_intersection(a: *mut jl_value_t, b: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_has_empty_intersection(
        x: *mut jl_value_t,
        y: *mut jl_value_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_type_unionall(v: *mut jl_tvar_t, body: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_typename_str(v: *mut jl_value_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_typeof_str(v: *mut jl_value_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_type_morespecific(a: *mut jl_value_t, b: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_unwrap_unionall(v: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_rewrap_unionall(t: *mut jl_value_t, u: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_typename_in(
        name: *mut jl_sym_t,
        inmodule: *mut jl_module_t,
    ) -> *mut jl_typename_t;
}
extern "C" {
    pub fn jl_new_typevar(
        name: *mut jl_sym_t,
        lb: *mut jl_value_t,
        ub: *mut jl_value_t,
    ) -> *mut jl_tvar_t;
}
extern "C" {
    pub fn jl_instantiate_unionall(u: *mut jl_unionall_t, p: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_type(
        tc: *mut jl_value_t,
        params: *mut *mut jl_value_t,
        n: usize,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_type1(tc: *mut jl_value_t, p1: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_type2(
        tc: *mut jl_value_t,
        p1: *mut jl_value_t,
        p2: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_apply_tuple_type(params: *mut jl_svec_t) -> *mut jl_tupletype_t;
}
extern "C" {
    pub fn jl_apply_tuple_type_v(p: *mut *mut jl_value_t, np: usize) -> *mut jl_tupletype_t;
}
extern "C" {
    pub fn jl_new_datatype(
        name: *mut jl_sym_t,
        module: *mut jl_module_t,
        super_: *mut jl_datatype_t,
        parameters: *mut jl_svec_t,
        fnames: *mut jl_svec_t,
        ftypes: *mut jl_svec_t,
        abstract_: ::std::os::raw::c_int,
        mutabl: ::std::os::raw::c_int,
        ninitialized: ::std::os::raw::c_int,
    ) -> *mut jl_datatype_t;
}
extern "C" {
    pub fn jl_new_primitivetype(
        name: *mut jl_value_t,
        module: *mut jl_module_t,
        super_: *mut jl_datatype_t,
        parameters: *mut jl_svec_t,
        nbits: usize,
    ) -> *mut jl_datatype_t;
}
extern "C" {
    pub fn jl_new_abstracttype(
        name: *mut jl_value_t,
        module: *mut jl_module_t,
        super_: *mut jl_datatype_t,
        parameters: *mut jl_svec_t,
    ) -> *mut jl_datatype_t;
}
extern "C" {
    pub fn jl_new_bits(bt: *mut jl_value_t, data: *mut ::std::os::raw::c_void) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_struct(type_: *mut jl_datatype_t, ...) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_structv(
        type_: *mut jl_datatype_t,
        args: *mut *mut jl_value_t,
        na: u32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_struct_uninit(type_: *mut jl_datatype_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_new_method_instance_uninit() -> *mut jl_method_instance_t;
}
extern "C" {
    pub fn jl_svec(n: usize, ...) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec1(a: *mut ::std::os::raw::c_void) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec2(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_alloc_svec(n: usize) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_alloc_svec_uninit(n: usize) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec_copy(a: *mut jl_svec_t) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_svec_fill(n: usize, x: *mut jl_value_t) -> *mut jl_svec_t;
}
extern "C" {
    pub fn jl_tupletype_fill(n: usize, v: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_symbol(str: *const ::std::os::raw::c_char) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_symbol_lookup(str: *const ::std::os::raw::c_char) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_symbol_n(str: *const ::std::os::raw::c_char, len: usize) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_gensym() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_tagged_gensym(str: *const ::std::os::raw::c_char, len: i32) -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_get_root_symbol() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_generic_function_def(
        name: *mut jl_sym_t,
        module: *mut jl_module_t,
        bp: *mut *mut jl_value_t,
        bp_owner: *mut jl_value_t,
        bnd: *mut jl_binding_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_method_def(argdata: *mut jl_svec_t, f: *mut jl_code_info_t, module: *mut jl_module_t);
}
extern "C" {
    pub fn jl_code_for_staged(linfo: *mut jl_method_instance_t) -> *mut jl_code_info_t;
}
extern "C" {
    pub fn jl_copy_code_info(src: *mut jl_code_info_t) -> *mut jl_code_info_t;
}
extern "C" {
    pub fn jl_get_world_counter() -> usize;
}
extern "C" {
    pub fn jl_get_kwsorter(ty: *mut jl_value_t) -> *mut jl_function_t;
}
extern "C" {
    pub fn jl_box_bool(x: i8) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int8(x: i8) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint8(x: u8) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int16(x: i16) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint16(x: u16) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int32(x: i32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint32(x: u32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_char(x: u32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_int64(x: i64) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_uint64(x: u64) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_float32(x: f32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_float64(x: f64) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_voidpointer(x: *mut ::std::os::raw::c_void) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_ssavalue(x: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_box_slotnumber(x: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_unbox_bool(v: *mut jl_value_t) -> i8;
}
extern "C" {
    pub fn jl_unbox_int8(v: *mut jl_value_t) -> i8;
}
extern "C" {
    pub fn jl_unbox_uint8(v: *mut jl_value_t) -> u8;
}
extern "C" {
    pub fn jl_unbox_int16(v: *mut jl_value_t) -> i16;
}
extern "C" {
    pub fn jl_unbox_uint16(v: *mut jl_value_t) -> u16;
}
extern "C" {
    pub fn jl_unbox_int32(v: *mut jl_value_t) -> i32;
}
extern "C" {
    pub fn jl_unbox_uint32(v: *mut jl_value_t) -> u32;
}
extern "C" {
    pub fn jl_unbox_int64(v: *mut jl_value_t) -> i64;
}
extern "C" {
    pub fn jl_unbox_uint64(v: *mut jl_value_t) -> u64;
}
extern "C" {
    pub fn jl_unbox_float32(v: *mut jl_value_t) -> f32;
}
extern "C" {
    pub fn jl_unbox_float64(v: *mut jl_value_t) -> f64;
}
extern "C" {
    pub fn jl_unbox_voidpointer(v: *mut jl_value_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_get_size(val: *mut jl_value_t, pnt: *mut usize) -> ::std::os::raw::c_int;
}
pub const jl_vararg_kind_t_JL_VARARG_NONE: jl_vararg_kind_t = 0;
pub const jl_vararg_kind_t_JL_VARARG_INT: jl_vararg_kind_t = 1;
pub const jl_vararg_kind_t_JL_VARARG_BOUND: jl_vararg_kind_t = 2;
pub const jl_vararg_kind_t_JL_VARARG_UNBOUND: jl_vararg_kind_t = 3;
pub type jl_vararg_kind_t = u32;
extern "C" {
    pub fn jl_field_index(
        t: *mut jl_datatype_t,
        fld: *mut jl_sym_t,
        err: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_nth_field(v: *mut jl_value_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_get_nth_field_noalloc(v: *mut jl_value_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_get_nth_field_checked(v: *mut jl_value_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_set_nth_field(v: *mut jl_value_t, i: usize, rhs: *mut jl_value_t);
}
extern "C" {
    pub fn jl_field_isdefined(v: *mut jl_value_t, i: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_field(o: *mut jl_value_t, fld: *const ::std::os::raw::c_char) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_value_ptr(a: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_islayout_inline(
        eltype: *mut jl_value_t,
        fsz: *mut usize,
        al: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_new_array(atype: *mut jl_value_t, dims: *mut jl_value_t) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_reshape_array(
        atype: *mut jl_value_t,
        data: *mut jl_array_t,
        dims: *mut jl_value_t,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_ptr_to_array_1d(
        atype: *mut jl_value_t,
        data: *mut ::std::os::raw::c_void,
        nel: usize,
        own_buffer: ::std::os::raw::c_int,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_ptr_to_array(
        atype: *mut jl_value_t,
        data: *mut ::std::os::raw::c_void,
        dims: *mut jl_value_t,
        own_buffer: ::std::os::raw::c_int,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_alloc_array_1d(atype: *mut jl_value_t, nr: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_alloc_array_2d(atype: *mut jl_value_t, nr: usize, nc: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_alloc_array_3d(
        atype: *mut jl_value_t,
        nr: usize,
        nc: usize,
        z: usize,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_pchar_to_array(str: *const ::std::os::raw::c_char, len: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_pchar_to_string(str: *const ::std::os::raw::c_char, len: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_cstr_to_string(str: *const ::std::os::raw::c_char) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_alloc_string(len: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_array_to_string(a: *mut jl_array_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_alloc_vec_any(n: usize) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_arrayref(a: *mut jl_array_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_ptrarrayref(a: *mut jl_array_t, i: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_arrayset(a: *mut jl_array_t, v: *mut jl_value_t, i: usize);
}
extern "C" {
    pub fn jl_arrayunset(a: *mut jl_array_t, i: usize);
}
extern "C" {
    pub fn jl_array_isassigned(a: *mut jl_array_t, i: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_array_grow_end(a: *mut jl_array_t, inc: usize);
}
extern "C" {
    pub fn jl_array_del_end(a: *mut jl_array_t, dec: usize);
}
extern "C" {
    pub fn jl_array_grow_beg(a: *mut jl_array_t, inc: usize);
}
extern "C" {
    pub fn jl_array_del_beg(a: *mut jl_array_t, dec: usize);
}
extern "C" {
    pub fn jl_array_sizehint(a: *mut jl_array_t, sz: usize);
}
extern "C" {
    pub fn jl_array_ptr_1d_push(a: *mut jl_array_t, item: *mut jl_value_t);
}
extern "C" {
    pub fn jl_array_ptr_1d_append(a: *mut jl_array_t, a2: *mut jl_array_t);
}
extern "C" {
    pub fn jl_apply_array_type(type_: *mut jl_value_t, dim: usize) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_array_ptr(a: *mut jl_array_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_array_eltype(a: *mut jl_value_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_array_rank(a: *mut jl_value_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_array_size(a: *mut jl_value_t, d: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn jl_string_ptr(s: *mut jl_value_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}jl_main_module"]
    pub static mut jl_main_module: *mut jl_module_t;
}
extern "C" {
    #[link_name = "\u{1}jl_internal_main_module"]
    pub static mut jl_internal_main_module: *mut jl_module_t;
}
extern "C" {
    #[link_name = "\u{1}jl_core_module"]
    pub static mut jl_core_module: *mut jl_module_t;
}
extern "C" {
    #[link_name = "\u{1}jl_base_module"]
    pub static mut jl_base_module: *mut jl_module_t;
}
extern "C" {
    #[link_name = "\u{1}jl_top_module"]
    pub static mut jl_top_module: *mut jl_module_t;
}
extern "C" {
    pub fn jl_new_module(name: *mut jl_sym_t) -> *mut jl_module_t;
}
extern "C" {
    pub fn jl_set_module_nospecialize(self_: *mut jl_module_t, on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_get_binding(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_get_binding_or_error(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_module_globalref(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_get_binding_wr(
        m: *mut jl_module_t,
        var: *mut jl_sym_t,
        error: ::std::os::raw::c_int,
    ) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_get_binding_for_method_def(
        m: *mut jl_module_t,
        var: *mut jl_sym_t,
    ) -> *mut jl_binding_t;
}
extern "C" {
    pub fn jl_boundp(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_defines_or_exports_p(
        m: *mut jl_module_t,
        var: *mut jl_sym_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_binding_resolved_p(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_const(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_global(m: *mut jl_module_t, var: *mut jl_sym_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_set_global(m: *mut jl_module_t, var: *mut jl_sym_t, val: *mut jl_value_t);
}
extern "C" {
    pub fn jl_set_const(m: *mut jl_module_t, var: *mut jl_sym_t, val: *mut jl_value_t);
}
extern "C" {
    pub fn jl_checked_assignment(b: *mut jl_binding_t, rhs: *mut jl_value_t);
}
extern "C" {
    pub fn jl_declare_constant(b: *mut jl_binding_t);
}
extern "C" {
    pub fn jl_module_using(to: *mut jl_module_t, from: *mut jl_module_t);
}
extern "C" {
    pub fn jl_module_use(to: *mut jl_module_t, from: *mut jl_module_t, s: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_module_import(to: *mut jl_module_t, from: *mut jl_module_t, s: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_module_export(from: *mut jl_module_t, s: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_is_imported(m: *mut jl_module_t, s: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_module_exports_p(m: *mut jl_module_t, var: *mut jl_sym_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_new_main_module() -> *mut jl_module_t;
}
extern "C" {
    pub fn jl_add_standard_imports(m: *mut jl_module_t);
}
extern "C" {
    pub fn jl_is_submodule(
        child: *mut jl_module_t,
        parent: *mut jl_module_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_eqtable_put(
        h: *mut jl_array_t,
        key: *mut ::std::os::raw::c_void,
        val: *mut ::std::os::raw::c_void,
        inserted: *mut ::std::os::raw::c_int,
    ) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_eqtable_get(
        h: *mut jl_array_t,
        key: *mut ::std::os::raw::c_void,
        deflt: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_set_errno(e: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_stat(
        path: *const ::std::os::raw::c_char,
        statbuf: *mut ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn jl_cpu_threads() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_getpagesize() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jl_getallocationgranularity() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jl_is_debugbuild() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_get_UNAME() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_get_ARCH() -> *mut jl_sym_t;
}
extern "C" {
    pub fn jl_environ(i: ::std::os::raw::c_int) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_error(str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_errorf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn jl_exceptionf(ty: *mut jl_datatype_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn jl_too_few_args(fname: *const ::std::os::raw::c_char, min: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_too_many_args(fname: *const ::std::os::raw::c_char, max: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_type_error(
        fname: *const ::std::os::raw::c_char,
        expected: *mut jl_value_t,
        got: *mut jl_value_t,
    );
}
extern "C" {
    pub fn jl_type_error_rt(
        fname: *const ::std::os::raw::c_char,
        context: *const ::std::os::raw::c_char,
        ty: *mut jl_value_t,
        got: *mut jl_value_t,
    );
}
extern "C" {
    pub fn jl_undefined_var_error(var: *mut jl_sym_t);
}
extern "C" {
    pub fn jl_bounds_error(v: *mut jl_value_t, t: *mut jl_value_t);
}
extern "C" {
    pub fn jl_bounds_error_v(v: *mut jl_value_t, idxs: *mut *mut jl_value_t, nidxs: usize);
}
extern "C" {
    pub fn jl_bounds_error_int(v: *mut jl_value_t, i: usize);
}
extern "C" {
    pub fn jl_bounds_error_tuple_int(v: *mut *mut jl_value_t, nv: usize, i: usize);
}
extern "C" {
    pub fn jl_bounds_error_unboxed_int(
        v: *mut ::std::os::raw::c_void,
        vt: *mut jl_value_t,
        i: usize,
    );
}
extern "C" {
    pub fn jl_bounds_error_ints(v: *mut jl_value_t, idxs: *mut usize, nidxs: usize);
}
extern "C" {
    pub fn jl_eof_error();
}
extern "C" {
    pub fn jl_exception_occurred() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_exception_clear();
}
extern "C" {
    pub fn jl_init();
}
extern "C" {
    pub fn jl_init_with_image(
        julia_bindir: *const ::std::os::raw::c_char,
        image_relative_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn jl_get_default_sysimg_path() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_is_initialized() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_atexit_hook(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_exit(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_pathname_for_handle(
        handle: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_deserialize_verify_header(s: *mut ios_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_preload_sysimg_so(fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_set_sysimg_so(handle: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn jl_create_system_image() -> *mut ios_t;
}
extern "C" {
    pub fn jl_save_system_image(fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_restore_system_image(fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_restore_system_image_data(buf: *const ::std::os::raw::c_char, len: usize);
}
extern "C" {
    pub fn jl_save_incremental(
        fname: *const ::std::os::raw::c_char,
        worklist: *mut jl_array_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_restore_incremental(
        fname: *const ::std::os::raw::c_char,
        depmods: *mut jl_array_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_restore_incremental_from_buf(
        buf: *const ::std::os::raw::c_char,
        sz: usize,
        depmods: *mut jl_array_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_parse_input_line(
        str: *const ::std::os::raw::c_char,
        len: usize,
        filename: *const ::std::os::raw::c_char,
        filename_len: usize,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_parse_string(
        str: *const ::std::os::raw::c_char,
        len: usize,
        pos0: ::std::os::raw::c_int,
        greedy: ::std::os::raw::c_int,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_load_file_string(
        text: *const ::std::os::raw::c_char,
        len: usize,
        filename: *mut ::std::os::raw::c_char,
        inmodule: *mut jl_module_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_expand(expr: *mut jl_value_t, inmodule: *mut jl_module_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_expand_stmt(expr: *mut jl_value_t, inmodule: *mut jl_module_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_eval_string(str: *const ::std::os::raw::c_char) -> *mut jl_value_t;
}
pub type jl_uv_libhandle = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn jl_load_dynamic_library(
        fname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> jl_uv_libhandle;
}
extern "C" {
    pub fn jl_load_dynamic_library_e(
        fname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> jl_uv_libhandle;
}
extern "C" {
    pub fn jl_dlopen(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> jl_uv_libhandle;
}
extern "C" {
    pub fn jl_dlclose(handle: jl_uv_libhandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_dlsym_e(
        handle: jl_uv_libhandle,
        symbol: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_dlsym(
        handle: jl_uv_libhandle,
        symbol: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn jl_toplevel_eval(m: *mut jl_module_t, v: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_toplevel_eval_in(m: *mut jl_module_t, ex: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_load(
        module: *mut jl_module_t,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_base_relative_to(m: *mut jl_module_t) -> *mut jl_module_t;
}
extern "C" {
    pub fn jl_trace_method(m: *mut jl_method_t);
}
extern "C" {
    pub fn jl_untrace_method(m: *mut jl_method_t);
}
extern "C" {
    pub fn jl_trace_linfo(linfo: *mut jl_method_instance_t);
}
extern "C" {
    pub fn jl_untrace_linfo(linfo: *mut jl_method_instance_t);
}
extern "C" {
    pub fn jl_register_linfo_tracer(
        callback: ::std::option::Option<unsafe extern "C" fn(tracee: *mut jl_method_instance_t)>,
    );
}
extern "C" {
    pub fn jl_register_method_tracer(
        callback: ::std::option::Option<unsafe extern "C" fn(tracee: *mut jl_method_instance_t)>,
    );
}
extern "C" {
    pub fn jl_register_newmeth_tracer(
        callback: ::std::option::Option<unsafe extern "C" fn(tracee: *mut jl_method_t)>,
    );
}
extern "C" {
    pub fn jl_copy_ast(expr: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_compress_ast(m: *mut jl_method_t, code: *mut jl_code_info_t) -> *mut jl_array_t;
}
extern "C" {
    pub fn jl_uncompress_ast(m: *mut jl_method_t, data: *mut jl_array_t) -> *mut jl_code_info_t;
}
extern "C" {
    pub fn jl_ast_flag_inferred(data: *mut jl_array_t) -> u8;
}
extern "C" {
    pub fn jl_ast_flag_inlineable(data: *mut jl_array_t) -> u8;
}
extern "C" {
    pub fn jl_ast_flag_pure(data: *mut jl_array_t) -> u8;
}
extern "C" {
    pub fn jl_fill_argnames(data: *mut jl_array_t, names: *mut jl_array_t);
}
extern "C" {
    pub fn jl_is_operator(sym: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_unary_operator(sym: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_is_unary_and_binary_operator(
        sym: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_operator_precedence(sym: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_apply_generic(args: *mut *mut jl_value_t, nargs: u32) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_invoke(
        meth: *mut jl_method_instance_t,
        args: *mut *mut jl_value_t,
        nargs: u32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_invoke_api(mi: *mut jl_method_instance_t) -> i32;
}
extern "C" {
    pub fn jl_call(
        f: *mut jl_function_t,
        args: *mut *mut jl_value_t,
        nargs: i32,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call0(f: *mut jl_function_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call1(f: *mut jl_function_t, a: *mut jl_value_t) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call2(
        f: *mut jl_function_t,
        a: *mut jl_value_t,
        b: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_call3(
        f: *mut jl_function_t,
        a: *mut jl_value_t,
        b: *mut jl_value_t,
        c: *mut jl_value_t,
    ) -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_yield();
}
extern "C" {
    pub fn jl_install_sigint_handler();
}
extern "C" {
    pub fn jl_sigatomic_begin();
}
extern "C" {
    pub fn jl_sigatomic_end();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_timing_block_t {
    _unused: [u8; 0],
}
pub type jl_timing_block_t = _jl_timing_block_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_handler_t {
    pub eh_ctx: sigjmp_buf,
    pub gcstack: *mut jl_gcframe_t,
    pub prev: *mut _jl_handler_t,
    pub gc_state: i8,
    pub defer_signal: sig_atomic_t,
    pub finalizers_inhibited: ::std::os::raw::c_int,
    pub timing_stack: *mut jl_timing_block_t,
    pub world_age: usize,
}
#[test]
fn bindgen_test_layout__jl_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_handler_t>(),
        248usize,
        concat!("Size of: ", stringify!(_jl_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_handler_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).eh_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(eh_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).gcstack as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(gcstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).prev as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).gc_state as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(gc_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).defer_signal as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(defer_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jl_handler_t>())).finalizers_inhibited as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(finalizers_inhibited)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).timing_stack as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(timing_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_handler_t>())).world_age as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_handler_t),
            "::",
            stringify!(world_age)
        )
    );
}
pub type jl_handler_t = _jl_handler_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_task_t {
    pub parent: *mut _jl_task_t,
    pub tls: *mut jl_value_t,
    pub state: *mut jl_sym_t,
    pub donenotify: *mut jl_value_t,
    pub result: *mut jl_value_t,
    pub exception: *mut jl_value_t,
    pub backtrace: *mut jl_value_t,
    pub logstate: *mut jl_value_t,
    pub start: *mut jl_function_t,
    pub ctx: sigjmp_buf,
    pub bufsz: usize,
    pub stkbuf: *mut ::std::os::raw::c_void,
    pub ssize: usize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub eh: *mut jl_handler_t,
    pub gcstack: *mut jl_gcframe_t,
    pub current_module: *mut jl_module_t,
    pub world_age: usize,
    pub tid: i16,
    pub timing_stack: *mut jl_timing_block_t,
}
#[test]
fn bindgen_test_layout__jl_task_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_task_t>(),
        352usize,
        concat!("Size of: ", stringify!(_jl_task_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_task_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).tls as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).donenotify as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(donenotify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).result as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).exception as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(exception)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).backtrace as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(backtrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).logstate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(logstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).start as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).ctx as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).bufsz as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(bufsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).stkbuf as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(stkbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).ssize as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(ssize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).eh as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(eh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).gcstack as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(gcstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).current_module as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(current_module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).world_age as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(world_age)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).tid as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_task_t>())).timing_stack as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_task_t),
            "::",
            stringify!(timing_stack)
        )
    );
}
impl _jl_task_t {
    #[inline]
    pub fn started(&self) -> usize {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_started(&mut self, val: usize) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(started: usize) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let started: u64 = unsafe { ::std::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type jl_task_t = _jl_task_t;
extern "C" {
    pub fn jl_new_task(start: *mut jl_function_t, ssize: usize) -> *mut jl_task_t;
}
extern "C" {
    pub fn jl_switchto(pt: *mut *mut jl_task_t);
}
extern "C" {
    pub fn jl_throw(e: *mut jl_value_t);
}
extern "C" {
    pub fn jl_rethrow();
}
extern "C" {
    pub fn jl_rethrow_other(e: *mut jl_value_t);
}
extern "C" {
    pub fn jl_no_exc_handler(e: *mut jl_value_t);
}
extern "C" {
    pub fn jl_enter_handler(eh: *mut jl_handler_t);
}
extern "C" {
    pub fn jl_pop_handler(n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn jl_run_event_loop(loop_: *mut uv_loop_t);
}
extern "C" {
    pub fn jl_run_once(loop_: *mut uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_process_events(loop_: *mut uv_loop_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_global_event_loop() -> *mut uv_loop_t;
}
extern "C" {
    pub fn jl_close_uv(handle: *mut uv_handle_t);
}
extern "C" {
    pub fn jl_tcp_bind(
        handle: *mut uv_tcp_t,
        port: u16,
        host: u32,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_sizeof_ios_t() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_take_buffer(s: *mut ios_t) -> *mut jl_array_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_uv_file_t {
    pub data: *mut ::std::os::raw::c_void,
    pub loop_: *mut uv_loop_t,
    pub type_: uv_handle_type,
    pub file: uv_os_fd_t,
}
#[test]
fn bindgen_test_layout_jl_uv_file_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_uv_file_t>(),
        24usize,
        concat!("Size of: ", stringify!(jl_uv_file_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_uv_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_uv_file_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).loop_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_uv_file_t>())).file as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_uv_file_t),
            "::",
            stringify!(file)
        )
    );
}
extern "C" {
    pub fn jl_uv_puts(stream: *mut uv_stream_t, str: *const ::std::os::raw::c_char, n: usize);
}
extern "C" {
    pub fn jl_printf(
        s: *mut uv_stream_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_vprintf(
        s: *mut uv_stream_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_safe_printf(str: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}jl_uv_stdin"]
    pub static mut jl_uv_stdin: *mut uv_stream_t;
}
extern "C" {
    #[link_name = "\u{1}jl_uv_stdout"]
    pub static mut jl_uv_stdout: *mut uv_stream_t;
}
extern "C" {
    #[link_name = "\u{1}jl_uv_stderr"]
    pub static mut jl_uv_stderr: *mut uv_stream_t;
}
extern "C" {
    pub fn jl_stdout_stream() -> *mut uv_stream_t;
}
extern "C" {
    pub fn jl_stdin_stream() -> *mut uv_stream_t;
}
extern "C" {
    pub fn jl_stderr_stream() -> *mut uv_stream_t;
}
extern "C" {
    pub fn jl_flush_cstdio();
}
extern "C" {
    pub fn jl_stdout_obj() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_stderr_obj() -> *mut jl_value_t;
}
extern "C" {
    pub fn jl_static_show(out: *mut uv_stream_t, v: *mut jl_value_t) -> usize;
}
extern "C" {
    pub fn jl_static_show_func_sig(s: *mut uv_stream_t, type_: *mut jl_value_t) -> usize;
}
extern "C" {
    pub fn jl_(jl_value: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_options_t {
    pub quiet: i8,
    pub banner: i8,
    pub julia_bindir: *const ::std::os::raw::c_char,
    pub julia_bin: *const ::std::os::raw::c_char,
    pub cmds: *mut *const ::std::os::raw::c_char,
    pub image_file: *const ::std::os::raw::c_char,
    pub cpu_target: *const ::std::os::raw::c_char,
    pub nprocs: i32,
    pub machine_file: *const ::std::os::raw::c_char,
    pub project: *const ::std::os::raw::c_char,
    pub isinteractive: i8,
    pub color: i8,
    pub historyfile: i8,
    pub startupfile: i8,
    pub compile_enabled: i8,
    pub code_coverage: i8,
    pub malloc_log: i8,
    pub opt_level: i8,
    pub debug_level: i8,
    pub check_bounds: i8,
    pub depwarn: i8,
    pub warn_overwrite: i8,
    pub can_inline: i8,
    pub polly: i8,
    pub trace_compile: *const ::std::os::raw::c_char,
    pub fast_math: i8,
    pub worker: i8,
    pub cookie: *const ::std::os::raw::c_char,
    pub handle_signals: i8,
    pub use_sysimage_native_code: i8,
    pub use_compiled_modules: i8,
    pub bindto: *const ::std::os::raw::c_char,
    pub outputbc: *const ::std::os::raw::c_char,
    pub outputunoptbc: *const ::std::os::raw::c_char,
    pub outputjitbc: *const ::std::os::raw::c_char,
    pub outputo: *const ::std::os::raw::c_char,
    pub outputji: *const ::std::os::raw::c_char,
    pub incremental: i8,
    pub image_file_specified: i8,
}
#[test]
fn bindgen_test_layout_jl_options_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_options_t>(),
        176usize,
        concat!("Size of: ", stringify!(jl_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_options_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).quiet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(quiet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).banner as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(banner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).julia_bindir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(julia_bindir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).julia_bin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(julia_bin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).cmds as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(cmds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).image_file as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(image_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).cpu_target as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(cpu_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).nprocs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(nprocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).machine_file as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(machine_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).project as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(project)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).isinteractive as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(isinteractive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).color as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).historyfile as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(historyfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).startupfile as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(startupfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).compile_enabled as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(compile_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).code_coverage as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(code_coverage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).malloc_log as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(malloc_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).opt_level as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(opt_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).debug_level as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(debug_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).check_bounds as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(check_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).depwarn as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(depwarn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).warn_overwrite as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(warn_overwrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).can_inline as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(can_inline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).polly as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(polly)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).trace_compile as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(trace_compile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).fast_math as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(fast_math)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).worker as *const _ as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(worker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).cookie as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).handle_signals as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(handle_signals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_options_t>())).use_sysimage_native_code as *const _ as usize
        },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(use_sysimage_native_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_options_t>())).use_compiled_modules as *const _ as usize
        },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(use_compiled_modules)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).bindto as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(bindto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputbc as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputunoptbc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputunoptbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputjitbc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputjitbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputo as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).outputji as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(outputji)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_options_t>())).incremental as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(incremental)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jl_options_t>())).image_file_specified as *const _ as usize
        },
        169usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_options_t),
            "::",
            stringify!(image_file_specified)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}jl_options"]
    pub static mut jl_options: jl_options_t;
}
extern "C" {
    pub fn jl_sizeof_jl_options() -> isize;
}
extern "C" {
    pub fn jl_parse_opts(
        argcp: *mut ::std::os::raw::c_int,
        argvp: *mut *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn jl_set_ARGS(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn jl_generating_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_major() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_minor() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_patch() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_is_release() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jl_ver_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_git_branch() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn jl_git_commit() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_nullable_float64_t {
    pub hasvalue: u8,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_jl_nullable_float64_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_nullable_float64_t>(),
        16usize,
        concat!("Size of: ", stringify!(jl_nullable_float64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_nullable_float64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_nullable_float64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float64_t>())).hasvalue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float64_t),
            "::",
            stringify!(hasvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float64_t>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float64_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_nullable_float32_t {
    pub hasvalue: u8,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_jl_nullable_float32_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_nullable_float32_t>(),
        8usize,
        concat!("Size of: ", stringify!(jl_nullable_float32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_nullable_float32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(jl_nullable_float32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float32_t>())).hasvalue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float32_t),
            "::",
            stringify!(hasvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_nullable_float32_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_nullable_float32_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jl_cgparams_t {
    pub cached: ::std::os::raw::c_int,
    pub track_allocations: ::std::os::raw::c_int,
    pub code_coverage: ::std::os::raw::c_int,
    pub static_alloc: ::std::os::raw::c_int,
    pub prefer_specsig: ::std::os::raw::c_int,
    pub module_setup: *mut jl_value_t,
    pub module_activation: *mut jl_value_t,
    pub raise_exception: *mut jl_value_t,
    pub emit_function: *mut jl_value_t,
    pub emitted_function: *mut jl_value_t,
}
#[test]
fn bindgen_test_layout_jl_cgparams_t() {
    assert_eq!(
        ::std::mem::size_of::<jl_cgparams_t>(),
        64usize,
        concat!("Size of: ", stringify!(jl_cgparams_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jl_cgparams_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jl_cgparams_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).cached as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(cached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).track_allocations as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(track_allocations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).code_coverage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(code_coverage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).static_alloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(static_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).prefer_specsig as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(prefer_specsig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).module_setup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(module_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).module_activation as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(module_activation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).raise_exception as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(raise_exception)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).emit_function as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(emit_function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jl_cgparams_t>())).emitted_function as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(jl_cgparams_t),
            "::",
            stringify!(emitted_function)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}jl_default_cgparams"]
    pub static mut jl_default_cgparams: jl_cgparams_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mallocarray_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bigval_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jl_value_t {
    pub _address: u8,
}
